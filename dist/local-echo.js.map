{"version":3,"sources":["webpack://LocalEchoController/webpack/bootstrap","webpack://LocalEchoController/./lib/HistoryController.js","webpack://LocalEchoController/./lib/Utils.js","webpack://LocalEchoController/./lib/LocalEchoController.js","webpack://LocalEchoController/./index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","HistoryController","size","_classCallCheck","this","entries","cursor","_createClass","entry","trim","length","push","pop","idx","Math","max","min","wordBoundaries","input","match","leftSide","arguments","undefined","words","rx","exec","index","closestLeftBoundary","offset","reverse","find","x","offsetToColRow","maxCols","row","col","charAt","countLines","LocalEchoController_LocalEchoController","LocalEchoController","term","historySize","LocalEchoController_classCallCheck","on","handleTermData","handleTermResize","history","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_termSize","cols","rows","fn","indexOf","splice","prompt","_this","continuationPrompt","Promise","resolve","reject","write","reason","message","print","normInput","replace","applyPrompts","substr","currentPrompt","allRows","_offsetToColRow","applyPromptOffset","moveRows","newInput","clearInput","newPrompt","newCursor","newLines","_offsetToColRow2","moveUpRows","inputWithPrompt","_offsetToColRow3","prevCol","prevRow","_offsetToColRow4","newCol","newRow","dir","num","setCursor","backspace","setInput","data","_this2","charCodeAt","normData","Array","from","forEach","handleData","ofs","ord","getPrevious","getNext","handleCursorMove","handleCursorErase","closestRightBoundary","split","endsWith","isIncompleteInput","handleReadComplete","handleCursorInsert","rewind","__webpack_exports__"],"mappings":"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","file":"local-echo.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * The history controller provides an ring-buffer\n */\nexport class HistoryController {\n  constructor(size) {\n    this.size = size;\n    this.entries = [];\n    this.cursor = 0;\n  }\n\n  /**\n   * Push an entry and maintain ring buffer size\n   */\n  push(entry) {\n    // Skip empty entries\n    if (entry.trim() === \"\") return;\n    // Skip duplicate entries\n    const lastEntry = this.entries[this.entries.length - 1];\n    if (entry == lastEntry) return;\n    // Keep track of entries\n    this.entries.push(entry);\n    if (this.entries.length > this.size) {\n      this.entries.pop(0);\n    }\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Rewind history cursor on the last entry\n   */\n  rewind() {\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Returns the previous entry\n   */\n  getPrevious() {\n    const idx = Math.max(0, this.cursor - 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n\n  /**\n   * Returns the next entry\n   */\n  getNext() {\n    const idx = Math.min(this.entries.length, this.cursor + 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n}\n","/**\n * Detects all the word boundaries on the given input\n */\nexport function wordBoundaries(input, leftSide = true) {\n  let match;\n  const words = [];\n  const rx = /\\w+/g;\n\n  while ((match = rx.exec(input))) {\n    if (leftSide) {\n      words.push(match.index);\n    } else {\n      words.push(match.index + match[0].length);\n    }\n  }\n\n  return words;\n}\n\n/**\n * The closest left (or right) word boundary of the given input at the\n * given offset.\n */\nexport function closestLeftBoundary(input, offset) {\n  return wordBoundaries(input, true)\n    .reverse()\n    .find(x => x < offset);\n}\nexport function closestRightBoundary(input, offset) {\n  return wordBoundaries(input, false).find(x => x > offset);\n}\n\n/**\n * Convert offset at the given input to col/row location\n *\n * This function is not optimized and practically emulates via brute-force\n * the navigation on the terminal, wrapping when they reach the column width.\n */\nexport function offsetToColRow(input, offset, maxCols) {\n  let row = 0,\n    col = 0;\n\n  for (let i = 0; i < offset; ++i) {\n    const chr = input.charAt(i);\n    if (chr == \"\\n\") {\n      col = 0;\n      row += 1;\n    } else {\n      col += 1;\n      if (col > maxCols) {\n        col = 0;\n        row += 1;\n      }\n    }\n  }\n\n  return { row, col };\n}\n\n/**\n * Counts the lines in the given input\n */\nexport function countLines(input, maxCols) {\n  return offsetToColRow(input, input.length, maxCols).row + 1;\n}\n\n/**\n * Checks if there is an incomplete input\n *\n * An incomplete input is considered:\n * - An input that contains unterminated single quotes\n * - An input that contains unterminated double quotes\n * - An input that ends with \"\\\"\n * - An input that has an incomplete boolean shell expression (&& and ||)\n * - An incomplete pipe expression (|)\n */\nexport function isIncompleteInput(input) {\n  // Empty input is not incomplete\n  if (input.trim() == \"\") {\n    return false;\n  }\n\n  // Check for dangling single-quote strings\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling double-quote strings\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling boolean or pipe operations\n  if (\n    input\n      .split(/(\\|\\||\\||&&)/g)\n      .pop()\n      .trim() == \"\"\n  ) {\n    return true;\n  }\n  // Check for tailing slash\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\n    return true;\n  }\n\n  return false;\n}\n","import { HistoryController } from \"./HistoryController\";\nimport {\n  closestLeftBoundary,\n  closestRightBoundary,\n  offsetToColRow,\n  countLines,\n  isIncompleteInput\n} from \"./Utils\";\n\n/**\n * A local terminal controller is responsible for displaying messages\n * and handling local echo for the terminal.\n *\n * Local echo supports most of bash-like input primitives. Namely:\n * - Arrow navigation on the input\n * - Alt-arrow for word-boundary navigation\n * - Alt-backspace for word-boundary deletion\n * - Multi-line input for incomplete commands\n * - Auto-complete hooks\n */\nexport default class LocalEchoController {\n  constructor(term, historySize = 10) {\n    this.term = term;\n    this.term.on(\"data\", this.handleTermData.bind(this));\n    this.term.on(\"resize\", this.handleTermResize.bind(this));\n    this.history = new HistoryController(historySize);\n\n    this._autocompleteHandlers = [];\n    this._active = false;\n    this._input = \"\";\n    this._cursor = 0;\n    this._activePrompt = null;\n    this._termSize = {\n      cols: this.term.cols,\n      rows: this.term.rows\n    };\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // User-Facing API\n  /////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Register a handler that will be called to satisfy auto-completion\n   */\n  addAutocompleteHandler(fn) {\n    this._autocompleteHandlers.push(fn);\n  }\n\n  /**\n   * Remove a previously registered auto-complete handler\n   */\n  removeAutocompleteHandler(fn) {\n    const idx = this._autocompleteHandlers.indexOf(fn);\n    if (idx === -1) return;\n\n    this._autocompleteHandlers.splice(idx, 1);\n  }\n\n  /**\n   * Return a promise that will resolve when the user has completed\n   * typing a single line\n   */\n  read(prompt, continuationPrompt = \"> \") {\n    return new Promise((resolve, reject) => {\n      this.term.write(prompt);\n      this._activePrompt = {\n        prompt,\n        continuationPrompt,\n        resolve,\n        reject\n      };\n\n      this._input = \"\";\n      this._cursor = 0;\n      this._active = true;\n    });\n  }\n\n  /**\n   * Abort a pending read operation\n   */\n  abortRead(reason = \"aborted\") {\n    if (this._activePrompt != null) {\n      this.term.write(\"\\r\\n\");\n      this._activePrompt.reject(reason);\n      this._activePrompt = null;\n    }\n    this._active = false;\n  }\n\n  /**\n   * Prints a message and changes line\n   */\n  println(message) {\n    this.print(message + \"\\n\");\n  }\n\n  /**\n   * Prints a message and properly handles new-lines\n   */\n  print(message) {\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\n    this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Internal API\n  /////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Apply prompts to the given input\n   */\n  applyPrompts(input) {\n    const prompt = (this._activePrompt || {}).prompt || \"\";\n    const continuationPrompt =\n      (this._activePrompt || {}).continuationPrompt || \"\";\n\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\n  }\n\n  /**\n   * Advances the `offset` as required in order to accompany the prompt\n   * additions to the input.\n   */\n  applyPromptOffset(input, offset) {\n    const newInput = this.applyPrompts(input.substr(0, offset));\n    return newInput.length;\n  }\n\n  /**\n   * Clears the current prompt\n   *\n   * This function will erase all the lines that display the current prompt\n   * and move the cursor in the beginning of the first line of the prompt.\n   */\n  clearInput() {\n    const currentPrompt = this.applyPrompts(this._input);\n\n    // Get the overall number of lines to clear\n    const allRows = countLines(currentPrompt, this._termSize.cols);\n\n    // Get the line we are currently in\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\n    const { col, row } = offsetToColRow(\n      currentPrompt,\n      promptCursor,\n      this._termSize.cols\n    );\n\n    // First move on the last line\n    const moveRows = allRows - row - 1;\n    for (var i = 0; i < moveRows; ++i) term.write(\"\\x1B[E\");\n\n    // Clear current input line(s)\n    term.write(\"\\r\\x1B[K\");\n    for (var i = 1; i < allRows; ++i) term.write(\"\\x1B[F\\x1B[K\");\n  }\n\n  /**\n   * Replace input with the new input given\n   *\n   * This function clears all the lines that the current input occupies and\n   * then replaces them with the new input.\n   */\n  setInput(newInput, clearInput = true) {\n    // Clear current input\n    if (clearInput) this.clearInput();\n\n    // Write the new input lines, including the current prompt\n    const newPrompt = this.applyPrompts(newInput);\n    this.print(newPrompt);\n\n    // Trim cursor overflow\n    if (this._cursor > newInput.length) {\n      this._cursor = newInput.length;\n    }\n\n    // Move the cursor to the appropriate row/col\n    const newCursor = this.applyPromptOffset(newInput, this._cursor);\n    const newLines = countLines(newPrompt, this._termSize.cols);\n    const { col, row } = offsetToColRow(\n      newPrompt,\n      newCursor,\n      this._termSize.cols\n    );\n    const moveUpRows = newLines - row - 1;\n\n    term.write(\"\\r\");\n    for (var i = 0; i < moveUpRows; ++i) term.write(\"\\x1B[F\");\n    for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\n\n    // Replace input\n    this._input = newInput;\n  }\n\n  /**\n   * Set the new cursor position, as an offset on the input string\n   *\n   * This function:\n   * - Calculates the previous and current\n   */\n  setCursor(newCursor) {\n    if (newCursor < 0) newCursor = 0;\n    if (newCursor > this._input.length) newCursor = this._input.length;\n\n    // Apply prompt formatting to get the visual status of the display\n    const inputWithPrompt = this.applyPrompts(this._input);\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\n\n    // Estimate previous cursor position\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\n    const { col: prevCol, row: prevRow } = offsetToColRow(\n      inputWithPrompt,\n      prevPromptOffset,\n      this._termSize.cols\n    );\n\n    // Estimate next cursor position\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\n    const { col: newCol, row: newRow } = offsetToColRow(\n      inputWithPrompt,\n      newPromptOffset,\n      this._termSize.cols\n    );\n\n    // Adjust vertically\n    if (newRow > prevRow) {\n      for (let i = prevRow; i < newRow; ++i) term.write(\"\\x1B[B\");\n    } else {\n      for (let i = newRow; i < prevRow; ++i) term.write(\"\\x1B[A\");\n    }\n\n    // Adjust horizontally\n    if (newCol > prevCol) {\n      for (let i = prevCol; i < newCol; ++i) term.write(\"\\x1B[C\");\n    } else {\n      for (let i = newCol; i < prevCol; ++i) term.write(\"\\x1B[D\");\n    }\n\n    // Set new offset\n    this._cursor = newCursor;\n  }\n\n  /**\n   * Move cursor at given direction\n   */\n  handleCursorMove(dir) {\n    if (dir > 0) {\n      const num = Math.min(dir, this._input.length - this._cursor);\n      this.setCursor(this._cursor + num);\n    } else if (dir < 0) {\n      const num = Math.max(dir, -this._cursor);\n      this.setCursor(this._cursor + num);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   */\n  handleCursorErase(backspace) {\n    const { _cursor, _input } = this;\n    if (backspace) {\n      if (_cursor <= 0) return;\n      const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);\n      this.clearInput();\n      this._cursor -= 1;\n      this.setInput(newInput, false);\n    } else {\n      const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);\n      this.setInput(newInput);\n    }\n  }\n\n  /**\n   * Insert character at cursor location\n   */\n  handleCursorInsert(data) {\n    const { _cursor, _input } = this;\n    const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);\n    this._cursor += 1;\n    this.setInput(newInput);\n  }\n\n  /**\n   * Handle input completion\n   */\n  handleReadComplete() {\n    if (this.history) {\n      this.history.push(this._input);\n    }\n    if (this._activePrompt) {\n      this._activePrompt.resolve(this._input);\n      this._activePrompt = null;\n    }\n    this.term.write(\"\\r\\n\");\n    this._active = false;\n  }\n\n  /**\n   * Handle terminal resize\n   *\n   * This function clears the prompt using the previous configuration,\n   * updates the cached terminal size information and then re-renders the\n   * input. This leads (most of the times) into a better formatted input.\n   */\n  handleTermResize(data) {\n    const { rows, cols } = data;\n    this.clearInput();\n    this._termSize = { cols, rows };\n    this.setInput(this._input, false);\n  }\n\n  /**\n   * Handle terminal input\n   */\n  handleTermData(data) {\n    if (!this._active) return;\n\n    // If this looks like a pasted input, expand it\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\n      Array.from(normData).forEach(c => this.handleData(c));\n    } else {\n      this.handleData(data);\n    }\n  }\n\n  /**\n   * Handle a single piece of information from the terminal.\n   */\n  handleData(data) {\n    if (!this._active) return;\n    const ord = data.charCodeAt(0);\n    let ofs;\n\n    // Handle ANSI escape sequences\n    if (ord == 0x1b) {\n      switch (data.substr(1)) {\n        case \"[A\": // Up arrow\n          if (this.history) {\n            let value = this.history.getPrevious();\n            if (value) {\n              this.setInput(value);\n              this.setCursor(value.length);\n            }\n          }\n          break;\n\n        case \"[B\": // Down arrow\n          if (this.history) {\n            let value = this.history.getNext();\n            if (!value) value = \"\";\n            this.setInput(value);\n            this.setCursor(value.length);\n          }\n          break;\n\n        case \"[D\": // Left Arrow\n          this.handleCursorMove(-1);\n          break;\n\n        case \"[C\": // Right Arrow\n          this.handleCursorMove(1);\n          break;\n\n        case \"[3~\": // Delete\n          this.handleCursorErase(false);\n          break;\n\n        case \"[F\": // End\n          this.setCursor(this._input.length);\n          break;\n\n        case \"[H\": // Home\n          this.setCursor(0);\n          break;\n\n        case \"b\": // ALT + LEFT\n          ofs = closestLeftBoundary(this._input, this._cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"f\": // ALT + RIGHT\n          ofs = closestRightBoundary(this._input, this._cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"\\x7F\": // CTRL + BACKSPACE\n          ofs = closestLeftBoundary(this._input, this._cursor);\n          if (ofs != null) {\n            this.setInput(\n              this._input.substr(0, ofs) + this._input.substr(this._cursor)\n            );\n            this.setCursor(ofs);\n          }\n          break;\n      }\n\n      // Handle special characters\n    } else if (ord < 32 || ord === 0x7f) {\n      switch (data) {\n        case \"\\r\": // ENTER\n          if (isIncompleteInput(this._input)) {\n            this.handleCursorInsert(\"\\n\");\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        case \"\\x7F\": // BACKSPACE\n          this.handleCursorErase(true);\n          break;\n\n        case \"\\t\": // TAB\n          this.handleCursorInsert(\"    \");\n          break;\n\n        case \"\\x03\": // CTRL+C\n          this.setCursor(this._input.length);\n          this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\n          this._input = \"\";\n          this._cursor = 0;\n          if (this.history) this.history.rewind();\n          break;\n      }\n\n      // Handle visible characters\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n}\n","import LocalEchoController from \"./lib/LocalEchoController\";\nexport { HistoryController } from './lib/HistoryController';\n\nexport default LocalEchoController;\n"],"sourceRoot":""}